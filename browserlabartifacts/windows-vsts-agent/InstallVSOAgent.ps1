
# Downloads the Visual Studio Online Build Agent and installs on the new machine
# and registers with the Visual Studio Online account and build agent pool

# Enable -Verbose option
[CmdletBinding()]
Param(
[Parameter(Mandatory=$true)]$VSOAccount,
[Parameter(Mandatory=$true)]$VSOUser,
[Parameter(Mandatory=$true)]$VSOPass,
[Parameter(Mandatory=$true)]$AgentName,
[Parameter(Mandatory=$true)]$PoolName
)

function DisplayArgValues
{
    WriteLog "========== Configuration =========="
    WriteLog $("-GitRepoLocation : " + $GitRepoLocation)
    WriteLog $("-GitLocalRepoLocation : " + $GitLocalRepoLocation)
    WriteLog $("-GitBranch : " + $GitBranch)
    WriteLog $("-PersonalAccessToken : " + $PersonalAccessToken)
    WriteLog "========== Configuration =========="
}

##################################################################################################

# 
# Description:
#  - Creates the folder structure which'll be used for dumping logs generated by this script and
#    the logon task.
#
# Parameters:
#  - N/A.
#
# Return:
#  - N/A.
#
# Notes:
#  - N/A.
#

function InitializeFolders
{
    if ($false -eq (Test-Path -Path $GitEnlisterFolder))
    {
        New-Item -Path $GitEnlisterFolder -ItemType directory | Out-Null
    }

    if ($false -eq (Test-Path -Path $ScriptLogFolder))
    {
        New-Item -Path $ScriptLogFolder -ItemType directory | Out-Null
    }
}

##################################################################################################

# 
# Description:
#  - Writes specified string to the console as well as to the script log (indicated by $ScriptLog).
#
# Parameters:
#  - $message: The string to write.
#
# Return:
#  - N/A.
#
# Notes:
#  - N/A.
#

function WriteLog
{
    Param(
        <# Can be null or empty #> $message
    )

    $timestampedMessage = $("[" + [System.DateTime]::Now + "] " + $message) | % {
        Out-File -InputObject $_ -FilePath $ScriptLog -Append
    }
}

##################################################################################################

try{

	InitializeFolders

	DisplayArgValues

	Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process -Force 

	WriteLog "Entering InstallVSOAgent.ps1" -verbose

	$currentLocation = Split-Path -parent $MyInvocation.MyCommand.Definition
	WriteLog "Current folder: $currentLocation" -verbose

	#Create a temporary directory where to download from VSTS the agent package (agent.zip) and then launch the configuration.
	$agentTempFolderName = Join-Path $env:temp ([System.IO.Path]::GetRandomFileName())
	New-Item -ItemType Directory -Force -Path $agentTempFolderName
	WriteLog "Temporary Agent download folder: $agentTempFolderName" -verbose

	$serverUrl = "https://$VSOAccount.visualstudio.com"
	WriteLog "Server URL: $serverUrl" -verbose

	$VSOAgentURL = "$serverUrl/_apis/distributedtask/packages/agent"
	WriteLog "VSO Agent URL: $VSOAgentURL" -verbose

	$retryCount = 3
	$retries = 1
	WriteLog "Downloading Agent install files" -verbose
	do
	{
	  try
	  {
		$basicAuth = ("{0}:{1}" -f $VSOUser,$VSOPass) 
		$basicAuth = [System.Text.Encoding]::UTF8.GetBytes($basicAuth)
		$basicAuth = [System.Convert]::ToBase64String($basicAuth)
		$headers = @{Authorization=("Basic {0}" -f $basicAuth)}

		Invoke-WebRequest -Uri $VSOAgentURL -headers $headers -Method Get -OutFile "$agentTempFolderName\agent.zip"
		WriteLog "Downloaded agent successfully on attempt $retries" -verbose
		break
	  }
	  catch
	  {
		$exceptionText = ($_ | Out-String).Trim()
		WriteLog "Exception occured downloading agent: $exceptionText in try number $retries" -verbose
		$retries++
		Start-Sleep -Seconds 30 
	  }
	} 
	while ($retries -le $retryCount)


	# Construct the agent folder under the main (hardcoded) C: drive.
	$agentInstallationPath = Join-Path "C:" $AgentName 
	# Create the directory for this agent.
	New-Item -ItemType Directory -Force -Path $agentInstallationPath 

	# Create a folder for the build work
	New-Item -ItemType Directory -Force -Path (Join-Path $agentInstallationPath $WorkFolder)


	WriteLog "Extracting the zip file for the agent" -verbose
	$destShellFolder = (new-object -com shell.application).namespace("$agentInstallationPath")
	$destShellFolder.CopyHere((new-object -com shell.application).namespace("$agentTempFolderName\agent.zip").Items(),16)

	# Removing the ZoneIdentifier from files downloaded from the internet so the plugins can be loaded
	# Don't recurse down _work or _diag, those files are not blocked and cause the process to take much longer
	WriteLog "Unblocking files" -verbose
	Get-ChildItem -Path $agentInstallationPath | Unblock-File | out-null
	Get-ChildItem -Recurse -Path $agentInstallationPath\Agent | Unblock-File | out-null

	# Retrieve the path to the vsoAgent.exe file.
	$agentExePath = [System.IO.Path]::Combine($agentInstallationPath, 'Agent', 'vsoAgent.exe')
	WriteLog "Agent Location = $agentExePath" -Verbose
	if (![System.IO.File]::Exists($agentExePath))
	{
		Write-Error "File not found: $agentExePath" -Verbose
		return
	}

	# Call the agent with the configure command and all the options (this creates the settings file) without prompting
	# the user or blocking the cmd execution

	WriteLog "Configuring agent" -Verbose


	# Set the current directory to the agent dedicated one previously created.
	Push-Location -Path $agentInstallationPath
	# The actual install of the agent. Using NetworkService as default service logon account, and some other values that could be turned into paramenters if needed 
	&start cmd.exe "/k $agentExePath /configure /RunningAsService /login:$VSOUser,$VSOPass /serverUrl:$serverUrl ""/WindowsServiceLogonAccount:NT AUTHORITY\NetworkService"" /WindowsServiceLogonPassword /WindowsServiceDisplayName:VsoBuildAgent /name:$AgentName /PoolName:$PoolName /WorkFolder:$WorkFolder /StartMode:Automatic /force /NoPrompt &exit"
	# Restore original current directory.
	Pop-Location


	WriteLog "Agent install output: $LASTEXITCODE" -Verbose

	WriteLog "Exiting InstallVSOAgent.ps1" -Verbose
}
catch
{
    if (($null -ne $Error[0]) -and ($null -ne $Error[0].Exception) -and ($null -ne $Error[0].Exception.Message))
    {
        $errMsg = $Error[0].Exception.Message
        WriteLog $errMsg
        Write-Host $errMsg
    }

    # Important note: Throwing a terminating error (using $ErrorActionPreference = "stop") still returns exit 
    # code zero from the powershell script. The workaround is to use try/catch blocks and return a non-zero 
    # exit code from the catch block. 
    return -1
}

